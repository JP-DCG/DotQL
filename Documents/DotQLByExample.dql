/* DotQL By Example */

/* Types: */

// List - sequential:
return [1 2 3]
// Set - unordered, unique:
return { 1 2 3 }
// Tuple:
return { Name: 'Sally' Age: 23 }
// Interval:
return 2..6
// Enumerations:
return Red	
// Void:
return void
// Scalar - intrinsic types:
return 456	// Integer (32bit), Long (64bit)
return true	// Boolean
return 'Hello'	// String (UTF16)
return '2012-12-12'd	// Date
return '15:30.2't // Time
return '2012-12-12'dt	// DateTime
return 2.4	// Double
return '84edd204-4b7d-45d0-9a3f-18f2fccc9732'g	// GUID
return '5d3h'ts	// TimeSpan
return 1.2.0	// Version

// Note: Commas and semi-colons are absent from expressions (noise-reduction)
// Note: The convention is to use a single space inside of single-line braces (e.g. { x }), but no space for brackets (e.g. [x])

/* Declaration */

// "Table" variable declaration:
Person: 
{
	{ 
		ID : Integer 
		Origin : String 
		ref Attributes(ID) Attribute(PersonID) 
		key (ID) 
	}
}

// Reads: The person member is a set of tuples, each having an ID, Origin, reference to Attributes, and identified by ID

// Note: The terms: tuple set, table, and relation are all synonymous

// Declaration of a variable of a set of integers:
Things: { Integer }

// Qualified name:
Height\Value: Integer
// ...if not ambiguous, may be accessed as:
return Value
// ...or
return Height\Value

/* Claused Expressions */

// FLWOR:
for ...
let ...
where ...
order ...
return ...
// All but return are optional, let may be repeated any number of times

// Simple cardinality 1 FLWOR
return 5

// Iterator - all clauses are per iteration:
for i in 1..5
return i
// returns [1 2 3 4 5]

// Let provides reuse:
let x := 5**5
return { Num: x Other: x + 1 }

// Where restricts result cardinality:
for i in 1..6
where i % 2 = 0
return i
// returns [2 4 6]

// Order specifies result ordering:
for i in 1..3
order i desc
return i
// returns [3 2 1]

/* Dotted Path Expressions */

// Base table access:
return Person
// returns entire person table. e.g. { { ID: 123 Origin: 'R' } { ID: 124 ...

// "Point" restriction:
return Person(ID = 234)
// e.g. { ID: 234 Origin: 'R' }
// Note: Result not in a set because cardinality 1 is detected due to equality restriction on entire key

// Regular restriction:
return Person(Origin = 'T')
// e.g. { { ID: 125 Origin: 'T' } { ID: 126...
// Result is a set (not a tuple) because Origin is not a key

// Restriction is arbitrary boolean expression:
return Gender(not IsFemale)
// e.g. { { ID: 456 IsFemale: false } ...

// Reference following (dereferencing):
return Person(ID = 123).Attributes
// e.g. { { ID: 456 PersonID: 123 Type: 'NG } { ID: 457 PersonID: 123 Type: 'G' } ...
// Attributes is a reference on the person tuple; accessing it gives attributes for all matching persons

// Equivalent query:
return Attributes(PersonID = 123)

// Doesn't matter if left side of dot is many:
return Person(Origin = 'R').Attributes
// reads: all attributes associated with persons that have origin of 'R'
// logically same as this:
return Attributes(exists Person(Origin = 'R' and ID = PersonID))

// Note: only the last table in a path sequence is returned, the prior tables serve to logically restrict said table

// Dotting through Extention (one to zero or one) relationships: 
return Person(ID = 123).Attributes.Name
// e.g. { { ID: 123 First: 'Bob' Last: 'Smith' ... } 
// Still a set cardinality because there can be any number of name attributes under a 
//  person (any n cardinality table along the path causes subsequent tables to be n cardinality)

// Single cardinality Extension:
return Attribute(ID = 456).Name
// e.g. { ID: 123 First: 'Bob' Last: 'Smith' ...  or null
// Singular cardinality because the Attribute query

/* Embedded Path Expressions */

// Embedded reference:
return Person(ID = 123)#Attributes
// e.g. { ID: 123 Origin: 'R' Attributes: { { ID: 234 PersonID: 123 Type: 'NG' } ... } 
// Note: A row from the Person table already has an Attributes member, but it is a reference, not an attribute;
//  this operator acts to "materialize" the reference as an embedded table attribute

// Dot paths following an embedded path:
return Person(ID = 123)#Attributes.Name
// e.g. { ID: 123 Origin: 'R' Attributes\Name: { { ID: 456 First: 'Bob' Last: 'Smith' } ... } }
// NOTE: remember that because Attributes\Name is a qualified name, it may be accessed as just Name if not ambiguous

// Dot paths preceeding an embedded path:
return Person(ID = 123).Attributes#Name
// e.g. { ID: 456 PersonID: 123 Type: 'NG' Name: { ID: 456 First: 'Bob' Last: 'Smith' } }

// Embedding multiple tables:
return Person(ID = 123).Attributes#(Name Gender)
// e.g.
//{
//	{ ID: 234 Type: 'NG' Name: { ID: 234 First: 'Bob' Last: 'Smith' } Gender: null }
//	{ ID: 345 Type: 'G' Name: null Gender: { ID: 345 IsFemale: false } }
//}

// Dereferencing multiple tables
return Person(ID = 123).Attributes.(Name Gender)
// Causes the table names to be nested as attributes in a new tuple.  e.g.
//{
//	{ Name: { ID: 234 First: 'Bob' Last: 'Smith' } Gender: null }
//	{ Name: null Gender: { ID: 345 IsFemale: false } }
// ...
//}

// Paths within claused expressions:
for a in Person(ID = 123).Attributes
return { ID: a.ID }
// e.g. { { ID: 456 } { ID: 457 } ... }

// Ordering always produces lists rather than sets (not for distinct purposes but for representing sequence):
for a in Person(ID = 123).Attributes
order a.ID
return { ID: a.ID }
// e.g. [{ ID: 456 } { ID: 457 } ...]

// Per the Relational Model, there is an implicit key over all attributes, so the following results in a list:
for a in Attributes
order a.Type
return { Type: a.Type }
// e.g. [{ Type: 'EB' } { Type: 'EM' } ...]

// Path restriction works on lists too:
return [{ ID: 123 } { ID: 124 }](ID > 123)
// returns [{ ID: 124 }]

// Reuse within paths:
for a in Person.Attributes
let n := ToLower(a.Type)
where n = 'ng'
return { ID: a.ID TypeUpper: ToUpper(n) TypeLower: n }

/* Item Extraction */

// List member extraction:
return [2 4 6 8][0]
// returns: 2

// Single member extraction:
return [2][]	// from list
// result: 2

return { 2 }[]	// from set
// result: 2

return [][]
// result null

return [2 4][]
// n cardinality results in runtime exception!

/* Explicit Typing */

// Empty list type selection:
return [] of [Integer]

// Explicitly designating type of list:
return [4] of [Long]

// Similar for sets
return { } of { String }

// Types for nulls:
return null of Integer

// Types for tuples:
return { ID: 135 } of { ID: Long }

/* Nulls */

// Resolving nulls:
return ([] of Integer)[0] ? 5;
// returns: 5
// The parentheses are not necessary, they are merely to clarify that the [0] is not part of the Integer type definition
// Note: out of range list extraction results in null, not error

// Determining null:
return Name[ID = 1212][].Prefix ??
// e.g. true if null either because there was no such row, or there was a row but the prefix wasn't present

// Tuple with optional attribute
return { First: 'Bob' } of { Prefix: String? First: String }
// result: { Prefix: null First: 'Bob' } 

/* Functions */

// Complex query needing reuse:
for p in Person
let orderedn :=
	for n in p.Attributes.Name
	let ap := n.Attribute.Priority
	order ap.Priority ? 0 desc n.ID
	return n
let pn := orderedn(Index = 0)
return { PersonID: p.ID  First: pn.First Last: pn.Last }
// returns perons ID's and the associated highest priority first and last name
// Need reuse...

// Function declaration:
let PreferredName := function(PersonID: Long): Name.MemberType
	let orderedn :=
		for n in Attributes(PersonID = args.PersonID).Name
		let ap := n.Attribute.Priority
		order ap.Priority ?? 0 desc n.ID
		return n
	return orderedn[0]

// Function usage:
for p in Person
let pn := PreferredName(p.ID)
return { ID: p.ID FName: pn.First LName: pn.Last  }

// Recursive function:
let SequentialSum := function(x: Integer): Integer
	return if x = 0 then 0 else x + SequentialSum(x - 1)
return SequentialSum(5)
// result: 15

// Accessing arguments as a tuple:
let Point := function(x: Integer y: Integer) 
	return { x: args.x y: args.y }
return Point(5 7)
// result: { x: 5 y: 7 }
// Alternatively, the Point function can be just this:
let Point := function(x: Integer y: Integer) 
	return args
// "args" is a tuple representation of the function's arguments

// Passing arguments as a tuple:
let Point := function(x: Integer y: Integer) 
	return args
return Point=>{ y: 5 x: 7 }
// result: { x: 7 y: 5 }  (attribute order never matters)

/* Conditions and cases */

// Conditional expression:
return if true then 'Hello' else 'Goodbye'
// returns 'Hello'

// Value based case expression:
let n := 123
return 
	case n 
		when 123 then 'Hello'
		when 234 then 'Goodbye'
		else 'Speechless'
	end
// returns 'Hello'

// Condition base case expression
let x := 123
let y := 234
return
	case
		when x = 135 and y = 231 then 'Hello'
		when true then 'Goodbye'
		else 'Speechless'
	end
// returns 'Goodbye'

// Strict cases:
Colors: enum { Green Red Blue }
return 
	case strict x // Error: this case statement must handle all colors
		when Green then 1 
		when Red then 2 
	end

/* Enumerations */

// Enumeration declaration:
Colors: enum { Red Yellow }

// Enumeration usage:
let PickOpposite := function(Color: Colors)
	return if Color = Red then Yellow else Red
return PickOpposite(Red)
// returns Yellow

// Dealing with enumeration symbol ambiguity:
let Colors := enum { Red Yellow }
let Personality := enum { Red Yellow Blue White }
return Red	
// ERROR: this conflicts with the Color Red
return Personality\Red
// returns Red (of type Personality)

/* Default Values */

// Defaults for each type are as follows:
// Numerics: 0
// String: ''
// Tuple: <each attribute defaulted>
// Set: <empty>
// List: <empty>
// Function: <function that returns default of return type>
// Interval: default..(default--)
// GUID: '00000000-0000-0000-0000-000000000000'g
// Enumerations: <first member>
// Version: 0.0.0
// Boolean: false

// TODO: Passing a tuple, casting a tuple, variables

/* Type Definitions */

// Type Definitions provide type description reuse:
SetOfNumbers: typedef { Integer }

// Type Definitions are pure short-hands though; for instance, these represent the same type:
PersonTuple1: typedef { Name: String Age: Integer }
PersonTuple2: typedef { Age: Integer Name: String }
// (order of attributes doesn't matter in a tuple, so these two typedefs are equivalent)
// Tuples, lists, and sets don't have meaningful names; their type description is their name

/* Modules */

// Declaring a module:
Ancestry\FamilyPaths: module 1.0.0
{
	Code: enum { Parent Sibling Child Spouse }
	Modifier: enum { Male Female Elder Younger Legal God Former Practical }
	Component: typedef { Code: Code Multiplier: Integer Modifiers: { Modifier } }
	Path: typedef [Component]
	Normalize: function(Path: Path) : Path
		return ...
	...
}

// Using a module:
using Ancestry\FamilyPaths 1.0.0
return Normalize([{ Code: Parent } { Code: Parent }])
// returns [{ Code: Parent Multiplier: 2 }]

// Module ambiguity:
using Ancestry\FamilyPaths 1.0.0
using Police 1.0.0
return Code\Fire	// ERROR: Code is ambiguous
// Valid:
return Police\Code\Fire
// NOTE: all module declaration and usage must include explicit version number

// Module aliases:
using fp := Ancestry\FamilyPaths 1.0.0
return fp\Code\Parent
// ... or just Code if not ambiguous

// Modules may contain the following members:
module ...
{
	Current: Integer // Variables
	Code: typedef Integer	// Type Definitions
	Colors: enum { Red Green }	// Enumerations
	BestNumber: const 5	// Constants
	Square: const function(x : Integer) return x * x	// Functions (as variables or consts)
}

/* Scripts */

// A script is composed of the following:
using Colors 1.2.0	// Any number of usings
module Cars 1.2.1 ...	// Any number of module declarations
var NewID := 123	// Any number of variable declarations
set NewID := GenerateID()	// Any number of assignment executions
return NewID	// Zero or one terminating claused expression
// NOTE: Non-determinism is allowed in any expression

// A script not ending in a claused expression implicitly has a result of void, but this can be explicit too:
using ...
...
return void

/* Updates */

// All mutation (side-effects) happens within Set assignments:
set	FavoriteColor := Green

// The left-hand side of assignments may contain reference-based path expressions:
set Person(ID = 123).Origin := 'R'
// effect: Updates the Origin attribute of the specified tuple of the Person table

// Set statements follow the FLWOR pattern except for Return becomes Set (FLWOS), and there may be any number of set clauses:
let p = Person(ID = 123)
set p := { ID: p.ID Origin: 'R' }
// effect: Updates the specified tuple of the Person table
// NOTE: Assignment of table references is logically a deletion of all matching tuples, followed by insertion of the given value(s)

// Deletion is enabled by assignment of nothing:
set Person(ID = 123) := null

// Insertion:
var newID: Long
set newID := GenerateID()
set Person(ID = newID) := { Origin: 'R' }
return newID
// effect: Generates a new ID, inserts a person tuple based on that ID, and returns the new ID

// Updating with iteration:
for i in 1..6
set Person(ID = i).Origin := 'R'
// effect: Sets the Origin attribute of a range of person tuples in the person table variable

/* Scope */

// Each script has a local frame, which hides any imported context:
using Ancestry\FamilyPaths 1.0.0
Code: Integer	// Hides the Code in FamilyPaths

// A module also defines a frame.  The script scope is not visible to a module:
Color: enum { Green Orange Red }
Fruits: module
{
	FruitColor: Color	// ERROR: Script level symbols are not visible in a module
}

// Module members can access other members, and in any order
Selfish: module
{
	Current: Code
	Code: typedef Integer
}

// Usings are global to the script, including within modules
using Ancestry\FamilyPaths 1.0.0
PeopleFinder: module 1.2.0
{
	Connection: typedef { SourceID: Long TargetID: Long Path: Path }
}

/* Exceptions */

// Try expression:
return try 1 / 0 catch -1
// returns -1

/* Nullological Cases */

// Empty set of normal tuples:
return { } of { { ID: Integer } }

// Empty lists of normal tuples:
return [] of [{ ID: Integer }]

// Empty tuple:
return { key () } of { ID: Integer key () }

// In an expression context { } means empty set; for a no-attribute tuple specify a key to distinguish that it is a tuple
// In a type context { } means a no-attribute tuple because a set requires a member type

// Set of type void:
return { }

// Set containing one no-attribute tuple ("table dee"):
return { { key () } }

// Set containing zero no-attribute tuples ("table dum"):
return { } of { { key() } }

// List of no-attribute tuples:
return [{ key () } { key () }]

// Empty set, of set of lists of sets of no-attribute tuples:
return { } of { [{ key () } of { key () }] }

/* Generics */

// Functions may take type arguments:
let Add = function<T>(T x T y)
	return x + y
return Add<Integer>(5 10)
// result: 15

The type parameter can be inferred:
return Add(5 10)

/* List Operations */

// Union:
return [1 2] | [2 3]
// result: [1 2 2 3]

// Push:
return Push([1 2] 3)
// result: [1 2 3]

// Pop:
return Pop([1 2 3])
// result: { Item: 3 Remaining: [1 2] }

// Enqueue:
return Enqueue([2 3] 1)
// result: [1 2 3]

// Dequeue is exactly the same as pop:
return Dequeue([1 2 3])
// result: { Item: 3 Remaining: [1 2] }

// Insert:
return Insert([1 3] 1 2)
// result: [1 2 3]
// 1 is the zero-based position, 2 is the value

// Remove at index:
return Remove([1 2 3] 1)
// result: [1 3]

// Removing based on value:
for i in [1 2 2 3]
where i <> 2
return i
// result: [1 3]

// Conversion to set:
return ToSet([5 5 6 6])
// result: { 5 6 }

// List membership:
return 5 in [1 3 5]
// result: true

// Detection of empty list:
return { exists [1] exists [] }
// result: { true false }

// Quota:
return [30 40 10 20][Index < 2]
// result: [30 40]

/* Set Operations */

// Intersection:
return { 1 2 } & { 2 3 }
// result: { 2 }

// Union:
return { 1 2 } | { 2 3 }
// result: { 1 2 3 }

// Subtraction:
return { 1 2 3 } - { 3 }
// result: { 1 }

// Conversion to list:
return ToList({ 2 1 3 })
// result: [1 2 3] (in order)

// Ordered conversion from set to list:
for i in { 2 3 1 }
order i	desc
return i
// result: [3 2 1]

// Set membership:
return 5 in { 1 3 5 }
// result: true

// Detection of empty set:
return { exists { 1 } exists { } }
// result: { true false }

// Quota:
return { 30 40 10 20 }[Index < 2]
// result: { 10 20 }

// Note: quota forces sorting for determinism; use list quote to control ordering

/* Attribute Extraction */

// Extraction of an attribute set from a tuple set:
return { { ID: 123 } { ID: 234 } { ID: 345 } }.ID
// result: {123 234 345 ...}

// Extraction of an attribute list from a tuple set:
let Items := { { ID: 123 Color: Red } { ID: 234 Color: Red } } as { { ID: Integer Color: Color key (ID) } }
return Items.Color
// result: [Red Red]  
// If the extracted attribute is not a key, the result is a list, not a set.  A Set result would be distinct, but this may not be desired (e.g. when counting)

// Extracting multiple attributes:
return { { x: 50 y: 100 z: 0 } { x: 75 y: 125 z:25 } }.(x y)
// result: [{ x: 50 y: 100 } { x: 75 y: 125 }]
// Again, because x and y don't represent a superset of a key (not necessarily proper) the result is a list

/* Aggregate Operations */

// Count function on a set: 
return Count({ 1 2 3 })
// result: 3
// This is a short-hand for Count<Integer>({ 1 2 3 })

// Count function on a list:
return Count([1 1 2 2])
// result: 4

// More aggregate functions:
var i := { 1 3 5 }
return { Min: Min(i) Max: Max(i) Avg: Avg(i) }
// result: { Min: 1 Max: 5 Avg: 3 }

// Logical aggregates:
var i := { true true false }
return { All: All(i) Any: Any(i) }
// result: { All: false Any: true }
// Logically equivalent to iterated AND and OR respectively

// Grouped aggregation:
for p in Person
return { Person: p NumAttributes: Count(p.Attributes) }
// e.g. { Person: { ID: 123 Origin: 'R' } NumAttributes: 12 }

// Count of distinct
return Count(ToSet(Person.Origin))
// The result is the number of distinct origins in the Person table

// String concatenation
return { Concat({ 'Zebra' 'Invasion' }) Concat(['Zebra' 'Invastion']) }
// result { 'InvastionZebra' 'ZebraInvasion' }

// Concatenation with delimiter
return { Concat(['Zebra' 'Invastion'] ' ') }
// result 'Zebra Invasion'

// Aggregates and nulls
return { S: Count({ 1 null 2 }) L: Count([1 null 2]) }
// result: { S: 2 L: 3 }

// Note: Nulls are not ever treated as existing in sets

/* Time/Date Operations */

// Selecting a Date from components:
return Date(1955 3 25)
// result: '1955/03/25'd

// Selecting a Time from components:
return Time(10, 15, 5.2)
// result: '10:15:5.2't

// Selecting a TimeSpan from components:
return TimeSpan(2, 1, 23, 100.1)
// result: '2d 1h 23m 100.1s'ts

// Selecting a Date from a tuple:
return Date({ Year: 1955 Month: 3 Day: 25 })
// result: '1955/03/25'd

// Adding Months:
return AddMonth(Date(1955 3 25) 2)
// result: '1955/05/25'd

// Adding Years:
return AddYear(Date(1955 3 25) 3)
// result: '1958/03/25'd

// Getting day-of-week:
return DayOfWeek('2004/04/19'd)
// result: 0 (Sunday)

// Getting day-of-year:
return DayOfYear('2004/11/18'd)
// result: 323

// Getting days in month:
return DaysInMonth(2004 2)
// result: 29

// Getting a time-span from dates:
return '1955/03/25'd - '1955/03/27'd
// result: '-2d'ts

// Getting the absolute duration:
return Abs('-2d'ts)
// result: '2d'ts

// Converting a Date to a tuple:
return ToTuple('1955/03/25'd)
// result: { Year: 1955 Month: 3 Day: 25 }

// Determining leap-year:
return IsLeapYear(2000)
// result: true

// Getting the date part of a DateTime:
return DatePart('2011/03/2 12:30:00'dt)
// result: '2011/03/2'd

// Getting the time part of a DateTime:
return DatePart('2011/03/2 12:30:00'dt)
// result: '12:30:00't

/* GUID Operations */

// Generate a new GUID:
return NewGUID() = NewGUID()
// result: extremely high probably of false
// NewGUID is not deterministic, watch out!

/* Bitwise Operations */

// Bitwise operators:
let n := 2;
return { Shl: n << 1 Shr: n >> 1 Inv: ~n Or: n | 1 And: n & 3 Xor: n ^ 3 }
// result: { Shl: 4 Shr: 1 Inv: -3 Or: 3 And: 2 Xor: 1 }

/* Numeric Operations */

// Arithmetic operators:
return { Add: 1 + 2 Sub: 4 - 1 IDiv: 3 / 2 DDiv: 3.0 / 2.0 Mul: 10 * 3 Neg: -55 Pow: 5**5 IMod: 5 % 3 FMod: 1.2 % 0.35 }
// result: { Add: 3 Sub: 3 IDiv: 1 DDiv: 1.5 Mul: 30 Neg: -55 Pow: 25 IMod: 2 FMod: 0.15 }

// Successor and predecessor for ordinal types:
return { Succ: ++1 Pred: --1 }
// result { Succ: 2 Pred: 0 }

// Absolute value:
return Abs(-3.2)
// result: 3.2

// Ceiling value:
return { Neg: Ceiling(-3.2) Pos: Ceiling(3.2) }
// result: { -3 4 }

// Floor value:
return { Neg: Floor(-3.2) Pos: Floor(3.2) }
// result: { -4 3 }

// Frac:
return 12.34
// result: 0.34

// Factorial:
return Factorial(10)
// result: 3628800

// Natural logarithm:
return Ln(6)
// result: 1.79175946922806

// Logarithm:
return Log(27 2)
// result: 4.75488750216347

// Base 10 logarithm:
return Log10(1000)
// result: 3

// Rounding:
let n := 3141.59265
return { Round(n 0) Round(n 2) Round(n -2) }
// result: { 3142 3141.59 3100 }

// Converting double's to integers:
return ToInteger(5.6)
// result: 5

// Comparisons:
return { Equal: 1 = 0 Compare1: 1 ?= 0 Compare2: 0 ?= 1 Compare3: 1 ?= 1 NotEqual: 1 <> 0 }
// result: { Equal: false Compare1: 1 Compare2: -1 Compare3: 0 NotEqual: true }

/* Random */

// Create random generator and getting number:
return Random(Seed()).Value
// result: { Seed: <mutated seed value> Value: <pseudo-random double between 0 and 1> }
// Note: Seed() is non-deterministic, but Random() is deterministic

// Generating multiple from the same seed:
let r1 := Random(Seed())
return { r1.Value Random(r1.Seed).Value }
// { <random value> <random value }

// Generating integers:
return Random(Seed() 99)
// result: <pseudo-random integer between 0-99>

// Generating in range:
return Random(Seed() 5..10)
// result: <pseudo-random integer between 5-10>

/* Generators */

// Generate an individual ID
return GenerateID('token')
// result: <next ID for given token> of Long

// Note: Generators start at 1

// ID Blocks
let n := GenerateID('token' 100)
return { n GenerateID('token') }
// result: { <next ID> <number at least 100 greater than prior }

// GenerateID is non-deterministic
 
/* String Operations */

// String concatenation:
return 'engine' + '-hitch-' + 'caboose\r\n'
// result: 'engine-hitch-caboose\r\n'

// Alternative concatenation:
return Concat(['engine' '-hitch-' 'caboose\r\n'])

// TODO: rest of string operators...

/* Interval Operations */

// Interval type declaration:
var i : interval Date

// Interval selector:
let dow := DayOfWeek(Today())
return (Today() - dow)..(Today() + (6 - dow))
// result: <dates of enveloping week, from Sunday to Sunday>

// Interval functions:
let i := 5..10
return { Contains(i 6) Before(i 10) After(i 11) Meets(i 11..13) Overlaps(i 10..15) Merges(i 1..4) Begins(i 5) Ends(i 10) }
// result { true false true true true true true true }

// TODO: Interval operators
