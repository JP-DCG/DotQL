/* DotQL BNF - The conventions here follow G4 */

Script =
	Statement [";" [Statement]]
		
Statement =
	UsingStatement
	| AssignmentStatement
	| ModuleStatement
	| ClausedExpression

UsingStatement =
	"using" [Identifier "="] Identifier

AssignmentStatement =
	PathExpression ":=" Expression

ModuleStatement =
	"module" Identifier ":

DeclarationStatement =
	"var" Identifier ":" Expression

ClausedExpression =
	["for" ForTerm]*
	["let" LetTerm]*
	["where" Expression]
	["order" OrderExpression^","]
	"return" Expression

ForTerm =
	Identifier "in" Expression

<let term =
	<identifier> ":=" <expression>
	
<order expression =
	<path expression> [asc | desc]

<expression =
	<claused expression> | <path expression>

<path expression =
    <logical and expression> <logical binary clause list>

<logical binary clause =
	<logical binary operator> <logical and expression>

<logical binary operator =
	in | or | xor | like | matches | before | after | meets | overlaps | merges | begins | ends 

<logical and expression = 
    <bitwise binary expression> {<logical and operator> <bitwise binary expression>}

<logical and operator =
    and

<bitwise binary expression = 
    <comparison expression> {<bitwise binary operator> <comparison expression>}

<bitwise binary operator =
    "^" | "&" | "|" | "<<" | ">>"

<comparison expression = 
    <additive expression> {<comparison operator> <additive expression>}

<comparison operator =
    "=" | "<>" | "<" | ">" | "<=" | ">=" | "?="

<additive expression = 
    <multiplicative expression> {<additive operator> <multiplicative expression>}

<additive operator =
    "+" | "-"

<multiplicative expression = 
    <exponent expression> {<multiplicative operator> <exponent expression>}

<multiplicative operator =
    "*" | "/" | "%"

<exponent expression = 
    <unary expression> {<exponent operator> <unary expression>}

<exponent operator =
    "**"

<unary expression =
	{<unary operator>} <indexer expression>

<unary operator =
	+ | - | ~ | not | exists

<indexer expression =
	<qualified factor>["["<expression>"]"]

<qualified factor =
	[.]{<factor>.}<factor>

<factor = 
    "("<expression>")" |
    [table]"("<query expression>")" |
    <literal> |
    <identifier> |
    <identifier>"("<expression commalist>")" |
    <identifier>"("[distinct] <expression>")" |
    <case expression>

<case expression =
    case [<expression>]
        <ne case item expression commalist>
        else <expression>
    end

<case item expression =
    when <expression> then <expression>

<qualified identifier =
    {<identifier>.}<identifier>

Lexer BNF ->

	The non terminals <letter>, <digit>, <hexdigit> and <character> have the obvious interpretations.

	<identifier =
		_ | <letter> {_ | <letter> | <digit>}

	<literal =
		<integer> |
		<float> |
		<decimal> |
		<numeric> |
		<money> |
		<string> |
		true |
		false |
		nil

	<integer =
		<digit>{<digit>} | 0x<hexdigit>{<hexdigit>}

	<float =
		<numeric>f

	<decimal =
		<numeric>[d]

	<numeric =
		<digit>{<digit>}[.{<digit>}][(e|E)[+|-]{<digit>}]
		
	<money =
		$<digit>{<digit>}[.{<digit>}]

	<string =
		""{<character>}"" | '{<character>}'
		
	<comment =
		-- <comment text> |
		/* <comment text> */
		
	<comment text =
		{<comment>}{<character>}{<comment>}

